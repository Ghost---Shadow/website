"use strict";(self.webpackChunkwebsite=self.webpackChunkwebsite||[]).push([[402],{7419:function(e,n,t){t.r(n),t.d(n,{default:function(){return i}});var s=t(2556),r=t.p+"static/media/utr.ddc1c80cf604fb361331.PNG";function a(e){const n=Object.assign({h1:"h1",h2:"h2",p:"p",a:"a",pre:"pre",code:"code",h3:"h3"},e.components);return(0,s.jsxs)(s.Fragment,{children:[(0,s.jsx)(n.h1,{children:"Unit Test Recorder - Automatically generate unit tests as you use your application"}),"\n",(0,s.jsx)("date",{children:"25 Jun 2020"}),"\n",(0,s.jsx)(n.h2,{children:"Introduction"}),"\n",(0,s.jsx)("img",{width:"100%",src:r,alt:"illustration"}),"\n",(0,s.jsx)(n.p,{children:"Input code on left and generated code on right."}),"\n",(0,s.jsxs)(n.p,{children:["This is a write up for the npm package ",(0,s.jsx)(n.a,{href:"https://www.npmjs.com/package/unit-test-recorder",children:"unit-test-recorder"})," or UTR for short."]}),"\n",(0,s.jsx)(n.p,{children:"The package is a CLI tool, which enables the user to record the activities flowing through every function in the nodejs application. This can then be turned into working unit test cases by string interpolation."}),"\n",(0,s.jsxs)(n.p,{children:["This tool is meant to be used for ",(0,s.jsx)(n.a,{href:"https://en.wikipedia.org/wiki/Regression_testing",children:"regression testing"})," using ",(0,s.jsx)(n.a,{href:"https://jestjs.io/docs/snapshot-testing",children:"snapshots"}),"."]}),"\n",(0,s.jsx)(n.p,{children:"The generated snapshots are human readable and editable code. The users are encouraged to take it forward and make changes to this code directly."}),"\n",(0,s.jsx)(n.h2,{children:"Methodology"}),"\n",(0,s.jsx)(n.p,{children:"In testing, we pass some arguments to the function under test and expect some result in return. If we are confident that the function in question is stable, then we can record the parameters and result as ground truth."}),"\n",(0,s.jsxs)(n.p,{children:["In order to record the parameters and results, we need to make some changes to the code itself. This process is called instrumentation. Instrumenters are used in many places including\ncode coverage runners like ",(0,s.jsx)(n.a,{href:"https://github.com/istanbuljs/istanbuljs",children:"istanbuljs"})," and monitoring services like\n",(0,s.jsx)(n.a,{href:"https://github.com/newrelic/node-newrelic",children:"new relic"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["UTR uses ",(0,s.jsx)(n.a,{href:"https://github.com/babel/babel",children:"babeljs"})," for injecting the recorder in the code."]}),"\n",(0,s.jsx)(n.p,{children:"Recording functions"}),"\n",(0,s.jsx)(n.p,{children:"Lets take this function as an example"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const foo = (a, b) => a + b;\n"})}),"\n",(0,s.jsx)(n.p,{children:"UTR uses babel to explicitly instrument it to"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const foo = (...p) => recorderWrapper(\n  { name: 'foo', fileName: 'bar' },\n  (a, b) => a + b,\n  ...p,\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["The ",(0,s.jsx)(n.code,{children:"recorderWrapper"})," function is provided by UTR. The function below is a simplified version of its implementation."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const recorderWrapper = (meta, fn, ...p) => {\n  const result = fn(...p);\n  Recorder.record({ meta, result, params: p });\n  return result;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"The meta property stores additional information regarding the nature of the function. e.g. The file name where the function was located, whether it returns a promise, whether it is the default export or named export and alike."}),"\n",(0,s.jsx)(n.p,{children:"This function records all calls to this function in a state. Here is a simplified representation of the state."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  "fileName":{\n    "functionName":{\n      "captures":[\n        { "params": [1, 2], "result": 3 },\n        { "params": [2, 3], "result": 5 },\n      ]\n    }\n  }\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"Now using string interpolation, we can generate test cases."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('fileName', () => {\n  describe('functionName', () => {\n    it('test 1', () => {\n      expect(foo(1, 2)).toEqual(3);\n    });\n    it('test 2', () => {\n      expect(foo(2, 3)).toEqual(5);\n    });\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Recording mocks"}),"\n",(0,s.jsx)(n.p,{children:"For recording mocks, we need to record all invocations of the imported function and correlate it to the function we are currently recording."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const fs = require('fs');\nconst foo = (fileName) => fs.readFileSync(fileName).toString().toUpperCase();\nconst bar = (fileName) => fs.readFileSync(fileName).toString().toLowerCase();\nconst baz = (f1, f2) => foo(f1) + bar(f2);\n"})}),"\n",(0,s.jsx)(n.p,{children:"The problem is that, if we instrument the mocked function naively, we would have no way to know which function invoked the mocked function."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"fs.wrappedReadFileSync = (...p) => recorderWrapper(\n  { name: 'fs.readFileSync' },\n  fs.readFileSync, // There is no way to know if foo invoked the function or bar or baz\n  ...p,\n);\nconst foo = (...p) => recorderWrapper(\n  { name: 'foo' },\n  (fileName) => fs.wrappedReadFileSync(fileName).toString().toUpperCase(),\n  ...p,\n);\nconst bar = (...p) => recorderWrapper(\n  { name: 'bar' },\n  (fileName) => fs.wrappedReadFileSync(fileName).toString().toUpperCase(),\n  ...p,\n);\nconst baz = (...p) => recorderWrapper(\n  { name: 'baz' },\n  (f1, f2) => foo(f1) + bar(f2),\n  ...p,\n);\n"})}),"\n",(0,s.jsxs)(n.p,{children:["Therefore the ",(0,s.jsx)(n.code,{children:"recorderWrapper"})," for the ",(0,s.jsx)(n.code,{children:"fs.readFileSync"})," must be aware\nof the JavaScript call stack or the ",(0,s.jsx)(n.a,{href:"https://archive.jlongster.com/Whats-in-a-Continuation",children:"continuation"}),".\n",(0,s.jsx)(n.a,{href:"https://github.com/Jeff-Lewis/cls-hooked",children:"Continuation local storage"})," is a popular JavaScript library built for this purpose.\nHowever in nodejs 13 and onward, native support exists in the form\nof ",(0,s.jsx)(n.a,{href:"https://nodejs.org/api/async_hooks.html#async_hooks_class_asynclocalstorage",children:"AsyncLocalStorage"}),"."]}),"\n",(0,s.jsxs)(n.p,{children:["To illustrate we now use two separate wrappers ",(0,s.jsx)(n.code,{children:"mockRecorderWrapper"})," and ",(0,s.jsx)(n.code,{children:"functionRecorderWrapper"}),"."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const functionRecorderWrapper = (meta, fn, ...p) => {\n  // Set the meta so that all invoked functions have access to it\n  cls.set('meta', meta);\n  return recorderWrapper(meta, fn, ...p);\n};\nconst mockRecorderWrapper = (mockMeta, fn, ...p) => {\n  // Get the meta of the function that invoked this mock\n  const invokerMeta = cls.get('meta');\n  // Use invoker meta to make sure the recordings are correlated correctly\n  return recorderWrapper({ ...mockMeta, ...invokerMeta }, fn, ...p);\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"Now, if the mocked function is invoked multiple times, we can save the sequence in an array"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:'{\n  "foo": [\n    {"moduleName": "fs", "functionName": "readFileSync", "params": [ "file1" ], "result": "file1_contents" },\n  ],\n  "bar": [\n    {"moduleName": "fs", "functionName": "readFileSync", "params": [ "file1" ], "result": "file1_contents" },\n  ],\n  "baz": [\n    {"moduleName": "fs", "functionName": "readFileSync", "params": [ "file1" ], "result": "file1_contents" },\n    {"moduleName": "fs", "functionName": "readFileSync", "params": [ "file2" ], "result": "file2_contents" },\n  ]\n}\n'})}),"\n",(0,s.jsx)(n.p,{children:"The generated tests look like so"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const fs = require('fs');\njest.mock('fs');\ndescribe('fileName', () => {\n  describe('baz', () => {\n    it('test 1', () => {\n      fs.readFileSync.mockImplementationOnce('file1_contents');\n      fs.readFileSync.mockImplementationOnce('file2_contents');\n      // baz is invoking foo and bar. They inturn are consuming the mocks\n      expect(baz('file1', 'file2')).toEqual('FILE1_CONTENTSfile2_contents');\n    });\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Dependency injections"}),"\n",(0,s.jsx)(n.p,{children:"Another common programming pattern in JavaScript involves using dependency injections. Often database clients are passed to functions like the example below."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const foo = async (dbClient) => {\n  const rows = await dbClient.query('SELECT COUNT(*) as usercount FROM users;');\n  return rows[0].usercount;\n};\n"})}),"\n",(0,s.jsxs)(n.p,{children:["In order to generate tests for the function ",(0,s.jsx)(n.code,{children:"foo"}),", we need to record\nthe ",(0,s.jsx)(n.code,{children:"query"})," function of the ",(0,s.jsx)(n.code,{children:"dbClient"})," argument. However, if we modify\nthe ",(0,s.jsx)(n.code,{children:"dbClient.query"})," function itself, it can lead to unintended side\neffects. Instead we create a new function at run time and use\nbabel to modify the source code to make sure the new created\nfunction will be used."]}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const foo = async (dbClient) => {\n  const rows = await dbClient.wrappedQuery('SELECT COUNT(*) as usercount FROM users;');\n  return rows[0].usercount;\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"The code below is a simplified version of the actual implementation"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Executed before the function is executed\nconst preExecutionHook = (wrappingMeta) => {\n  // wrappingMeta looks similar to { objectName: 'dbClient', fnName: 'query' };\n  const { fnName } = wrappingMeta;\n  const newFnName = generateNewFnName(wrappingMeta); // \"wrappedQuery\" in this case\n  // dbClient.wrappedQuery created at runtime\n  dbClient[newFnName] = (...p) => {\n    const invokerMeta = cls.get('meta');\n    const fn = dbClient[fnName];\n    return recorderWrapper({ ...wrappingMeta, ...invokerMeta }, fn, ...p);\n  };\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"In the generated tests, we mock the methods of the injected object like so"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('fileName', () => {\n  describe('foo', () => {\n    it('test 1', () => {\n      const dbClient = {};\n      dbClient.query.mockImplementationOnce([{ usercount: 20 }]);\n      expect(foo(dbClient)).toEqual(20);\n    });\n  });\n});\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Injection promotions"}),"\n",(0,s.jsx)(n.p,{children:"To make the test generation process data efficient, we use injection promotions. In the example below, even if the function bar is never invoked separately, we can piggyback on the invocation of foo to generate tests for both foo and bar."}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"const bar = (client, status) => client.query('SELECT COUNT(*) FROM users WHERE status=$1', status);\nconst foo = async (dbClient) => {\n  const offlineUsers = await bar(dbClient, 'offline');\n  const activeUsers = await dbClient.query('SELECT COUNT(*) FROM users WHERE status=$1', 'active');\n  const awayUsers = await bar(dbClient, 'away');\n  return { offlineUsers, activeUsers, awayUsers };\n};\n"})}),"\n",(0,s.jsx)(n.p,{children:"Although testing foo also covers bar, the separate tests for bar\nact as scaffolding for any future modifications to the function\nbar. Hence, the design decision."}),"\n",(0,s.jsx)(n.p,{children:"The generated tests look like so"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"describe('fileName', () => {\n  describe('bar', () => {\n    it('test 1', () => {\n      const dbClient = {};\n      dbClient.query.mockImplementationOnce(10);\n      expect(bar(dbClient, 'offline')).toEqual(10);\n    });\n    it('test 2', () => {\n      const dbClient = {};\n      dbClient.query.mockImplementationOnce(30);\n      expect(bar(dbClient, 'away')).toEqual(30);\n    });\n  });\n  describe('foo', () => {\n    it('test 1', () => {\n      const dbClient = {};\n      dbClient.query.mockImplementationOnce(10); // Promoted from bar\n      dbClient.query.mockImplementationOnce(20);\n      dbClient.query.mockImplementationOnce(30); // Promoted from bar\n      const expected = { offlineUsers: 10, activeUsers: 20, awayUsers: 30 };\n      expect(foo(dbClient)).toEqual(expected);\n    });\n  });\n});\n"})}),"\n",(0,s.jsx)(n.p,{children:"Promotions are handled internally by maintaining an implicit stack. When a function's scope ends, all the recorded dependency injections are passed on to its parent."}),"\n",(0,s.jsx)(n.p,{children:"We use uuidv4 to correctly identify injected functions for promotions as variable names need not be consistent between parent and child."}),"\n",(0,s.jsx)(n.h3,{children:"1st invocation to dbClient.query"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"fooCaptures = {\n  captures: [], // foo has not called dbClient.query yet\n};\nbarCaptures = {\n  captures: [\n    {\n      injectedFunctionUUid: 'uuid1',\n      params: [\n        'SELECT COUNT(*) FROM users WHERE status=$1',\n        'offline',\n      ],\n      result: 10,\n    },\n  ],\n};\n"})}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// When bar finishes, the captures are promoted to its parent\nfooCaptures = {\n  captures: [\n    {\n      injectedFunctionUUid: 'uuid1',\n      params: [\n        'SELECT COUNT(*) FROM users WHERE status=$1',\n        'offline',\n      ],\n      result: 10,\n    },\n  ],\n};\n"})}),"\n",(0,s.jsx)(n.h3,{children:"2nd invocation to dbClient.query"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// When foo invokes dbClient.query directly, it gets added to the captures array\nfooCaptures = {\n  captures: [\n    {\n      injectedFunctionUUid: 'uuid1',\n      params: [\n        'SELECT COUNT(*) FROM users WHERE status=$1',\n        'offline',\n      ],\n      result: 10,\n    },\n    {\n      injectedFunctionUUid: 'uuid1',\n      params: [\n        'SELECT COUNT(*) FROM users WHERE status=$1',\n        'active',\n      ],\n      result: 20,\n    },\n  ],\n};\n"})}),"\n",(0,s.jsx)(n.h3,{children:"3rd invocation to dbClient.query"}),"\n",(0,s.jsx)(n.pre,{children:(0,s.jsx)(n.code,{className:"language-js",children:"// Foo stack so far\nfooCaptures = {\n  captures: [\n    {\n      injectedFunctionUUid: 'uuid1',\n      params: [\n        'SELECT COUNT(*) FROM users WHERE status=$1',\n        'offline',\n      ],\n      result: 10,\n    },\n    {\n      injectedFunctionUUid: 'uuid1',\n      params: [\n        'SELECT COUNT(*) FROM users WHERE status=$1',\n        'active',\n      ],\n      result: 20,\n    },\n  ],\n};\n// When bar is invoked, the injections are captured for bar\nbarCaptures = {\n  captures: [\n    {\n      injectedFunctionUUid: 'uuid1',\n      params: [\n        'SELECT COUNT(*) FROM users WHERE status=$1',\n        'away',\n      ],\n      result: 30,\n    },\n  ],\n};\n// Finally, when scope of bar ends, injections are promoted\nfooCaptures = {\n  captures: [\n    {\n      injectedFunctionUUid: 'uuid1',\n      params: [\n        'SELECT COUNT(*) FROM users WHERE status=$1',\n        'offline',\n      ],\n      result: 10,\n    },\n    {\n      injectedFunctionUUid: 'uuid1',\n      params: [\n        'SELECT COUNT(*) FROM users WHERE status=$1',\n        'active',\n      ],\n      result: 20,\n    },\n    {\n      injectedFunctionUUid: 'uuid1',\n      params: [\n        'SELECT COUNT(*) FROM users WHERE status=$1',\n        'away',\n      ],\n      result: 30,\n    },\n  ],\n};\n"})}),"\n",(0,s.jsx)(n.h2,{children:"Conclusion"}),"\n",(0,s.jsx)(n.p,{children:"Other than the usual benefits of software testing, this is also a quick and inexpensive way to generate a dataset of test code, corresponding to a corpora of existing code. This can be used by researchers working on deep learning based code generation tools."})]})}var i=function(e={}){const{wrapper:n}=e.components||{};return n?(0,s.jsx)(n,Object.assign({},e,{children:(0,s.jsx)(a,e)})):a(e)}}}]);
//# sourceMappingURL=402.c85c232d.chunk.js.map